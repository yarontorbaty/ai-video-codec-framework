<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Codec Research Blog - Autonomous Learning Journey</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        .blog-container {
            max-width: 900px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .blog-header {
            text-align: center;
            margin-bottom: 60px;
        }

        .blog-header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .blog-header p {
            font-size: 1.2em;
            color: #666;
        }

        .summary-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 12px;
            padding: 40px;
            margin-bottom: 50px;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.3);
        }

        .summary-section h2 {
            font-size: 2em;
            margin-bottom: 20px;
            color: white;
        }

        .summary-section p {
            font-size: 1.1em;
            line-height: 1.8;
            margin-bottom: 15px;
            opacity: 0.95;
        }

        .summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .summary-stat {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
        }

        .summary-stat .value {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .summary-stat .label {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .blog-post {
            background: white;
            border-radius: 12px;
            padding: 40px;
            margin-bottom: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-left: 4px solid #667eea;
        }

        .blog-post h2 {
            font-size: 1.8em;
            margin-bottom: 10px;
            color: #333;
        }

        .blog-meta {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            font-size: 0.9em;
            color: #666;
        }

        .blog-meta span {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
        }

        .status-failed {
            background: #f8d7da;
            color: #721c24;
        }

        .status-running {
            background: #fff3cd;
            color: #856404;
        }

        .achievement-badge {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 600;
        }

        .achievement-90 {
            background: #fef3c7;
            color: #92400e;
            border: 2px solid #fbbf24;
        }

        .achievement-70 {
            background: #d1fae5;
            color: #065f46;
            border: 2px solid #10b981;
        }

        .achievement-50 {
            background: #dbeafe;
            color: #1e40af;
            border: 2px solid #60a5fa;
        }

        .achievement-wip {
            background: #f1f5f9;
            color: #475569;
            border: 2px solid #94a3b8;
        }

        .blog-section {
            margin: 30px 0;
        }

        .blog-section h3 {
            font-size: 1.3em;
            margin-bottom: 15px;
            color: #667eea;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }

        .blog-section p {
            line-height: 1.8;
            color: #555;
            margin-bottom: 15px;
        }

        .blog-section ul {
            padding-left: 25px;
            line-height: 1.8;
            color: #555;
        }

        .blog-section li {
            margin-bottom: 10px;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .metric-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            border: 2px solid #e9ecef;
        }

        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .metric-label {
            font-size: 0.9em;
            color: #666;
        }

        .confidence-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transition: width 0.5s;
        }

        .loading {
            text-align: center;
            padding: 60px 20px;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: #667eea;
            text-decoration: none;
            font-weight: 600;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        .code-snippet {
            background: #f8f9fa;
            border-left: 3px solid #667eea;
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #495057;
            overflow-x: auto;
        }

        .recommendation-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 20px;
            border-radius: 4px;
            margin: 15px 0;
        }

        .recommendation-box h4 {
            color: #856404;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .recommendation-box p {
            color: #856404;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="blog-container">
        <a href="index.html" class="back-link">‚Üê Back to Dashboard</a>
        
        <div class="blog-header">
            <h1>ü§ñ Autonomous AI Research Blog</h1>
            <p>Follow the journey of an AI that learns to compress video better than HEVC</p>
        </div>

        <div id="summary-section">
            <!-- Summary will be inserted here -->
        </div>

        <div id="blog-posts">
            <div class="loading">
                <div class="loading-spinner"></div>
                <p>Loading AI research insights...</p>
            </div>
        </div>
    </div>

    <script>
        const API_BASE_URL = 'https://pbv4wnw8zd.execute-api.us-east-1.amazonaws.com/production';

        async function loadBlogPosts() {
            try {
                // Fetch experiments data
                const experimentsRes = await fetch(`${API_BASE_URL}/dashboard?type=experiments`);
                const experimentsData = await experimentsRes.json();
                const experiments = experimentsData.experiments || [];

                // Create blog posts structure with full experiment data
                const blogPosts = await Promise.all(experiments.map(async exp => {
                    // Fetch full experiment details from DynamoDB
                    try {
                        const detailsRes = await fetch(`${API_BASE_URL}/dashboard?type=experiment&id=${exp.id}`);
                        const details = await detailsRes.json();
                        return {
                            experiment: exp,
                            details: details
                        };
                    } catch (e) {
                        return {
                            experiment: exp,
                            details: null
                        };
                    }
                }));

                renderSummary(blogPosts);
                renderBlogPosts(blogPosts);
            } catch (error) {
                console.error('Error loading blog posts:', error);
                document.getElementById('blog-posts').innerHTML = `
                    <div class="blog-post">
                        <h2>‚ö†Ô∏è Unable to Load Blog Posts</h2>
                        <p>Error: ${error.message}</p>
                        <p>The AI is still learning. Check back soon!</p>
                    </div>
                `;
            }
        }

        function renderSummary(posts) {
            const summaryContainer = document.getElementById('summary-section');
            
            if (posts.length === 0) {
                summaryContainer.innerHTML = '';
                return;
            }

            // Calculate overall statistics
            const completedExperiments = posts.filter(p => p.experiment.status === 'completed');
            const bestBitrate = Math.min(...completedExperiments.map(p => p.experiment.bitrate || 999));
            const avgBitrate = completedExperiments.length > 0 ? 
                completedExperiments.reduce((sum, p) => sum + (p.experiment.bitrate || 0), 0) / completedExperiments.length : 0;
            
            // Find experiments that achieved tiers
            const tier90 = completedExperiments.filter(p => p.experiment.bitrate <= 1.0).length;
            const tier70 = completedExperiments.filter(p => p.experiment.bitrate <= 3.0 && p.experiment.bitrate > 1.0).length;
            const tier50 = completedExperiments.filter(p => p.experiment.bitrate <= 5.0 && p.experiment.bitrate > 3.0).length;

            // Determine current status
            let statusText = '';
            let currentTier = '';
            if (bestBitrate <= 1.0) {
                statusText = `üèÜ Breakthrough! We've achieved 90% reduction from HEVC baseline (10 Mbps ‚Üí ${bestBitrate.toFixed(2)} Mbps). This represents state-of-the-art compression performance.`;
                currentTier = '90%';
            } else if (bestBitrate <= 3.0) {
                statusText = `ü•á Excellent progress! We've achieved 70% reduction from HEVC baseline (10 Mbps ‚Üí ${bestBitrate.toFixed(2)} Mbps). The AI is making strong gains through iterative learning.`;
                currentTier = '70%';
            } else if (bestBitrate <= 5.0) {
                statusText = `ü•à Good progress! We've achieved 50% reduction from HEVC baseline (10 Mbps ‚Üí ${bestBitrate.toFixed(2)} Mbps). The system is successfully improving with each iteration.`;
                currentTier = '50%';
            } else {
                statusText = `üéØ Early stages. Current best: ${bestBitrate.toFixed(2)} Mbps. The AI is exploring different compression approaches to find what works best.`;
                currentTier = 'In Progress';
            }

            summaryContainer.innerHTML = `
                <div class="summary-section">
                    <h2>üìä Research Progress Summary</h2>
                    <p>${statusText}</p>
                    <p>The autonomous AI has run <strong>${posts.length} experiments</strong>, iteratively learning from each result to design better compression algorithms. Each experiment builds on insights from the previous iteration.</p>
                    
                    <div class="summary-stats">
                        <div class="summary-stat">
                            <div class="value">${posts.length}</div>
                            <div class="label">Total Experiments</div>
                        </div>
                        <div class="summary-stat">
                            <div class="value">${bestBitrate.toFixed(2)}</div>
                            <div class="label">Best Bitrate (Mbps)</div>
                        </div>
                        <div class="summary-stat">
                            <div class="value">${currentTier}</div>
                            <div class="label">Current Tier</div>
                        </div>
                        <div class="summary-stat">
                            <div class="value">${((10 - bestBitrate) / 10 * 100).toFixed(0)}%</div>
                            <div class="label">Best Reduction</div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderBlogPosts(posts) {
            const container = document.getElementById('blog-posts');

            if (posts.length === 0) {
                container.innerHTML = `
                    <div class="blog-post">
                        <h2>üöÄ First Experiments Starting Soon</h2>
                        <p>The autonomous AI system is initializing. The first experiment analysis will appear here within 6 hours.</p>
                        <p>Each blog post will include:</p>
                        <ul>
                            <li><strong>Methods:</strong> Detailed description of what this experiment is trying</li>
                            <li><strong>Results:</strong> Performance metrics and achievement tier</li>
                            <li><strong>Analysis:</strong> What worked, what didn't, and why</li>
                            <li><strong>Recommendations:</strong> What the AI suggests trying next</li>
                        </ul>
                    </div>
                `;
                return;
            }

            // Sort by timestamp, newest first
            posts.sort((a, b) => (b.experiment.timestamp || 0) - (a.experiment.timestamp || 0));

            container.innerHTML = posts.map((post, index) => 
                renderBlogPost(post, posts.length - index, posts[index + 1])
            ).join('');
        }

        function renderBlogPost(post, experimentNumber, previousPost) {
            const exp = post.experiment;
            const details = post.details;

            const statusClass = exp.status === 'completed' ? 'status-success' : 
                               exp.status === 'failed' ? 'status-failed' : 'status-running';

            // Calculate achievement tier
            let achievementClass = 'achievement-wip';
            let achievementIcon = 'üéØ';
            let achievementText = 'In Progress';
            const reduction = ((10 - exp.bitrate) / 10 * 100);
            
            if (exp.bitrate <= 1.0) {
                achievementClass = 'achievement-90';
                achievementIcon = 'üèÜ';
                achievementText = '90% Reduction';
            } else if (exp.bitrate <= 3.0) {
                achievementClass = 'achievement-70';
                achievementIcon = 'ü•á';
                achievementText = '70% Reduction';
            } else if (exp.bitrate <= 5.0) {
                achievementClass = 'achievement-50';
                achievementIcon = 'ü•à';
                achievementText = '50% Reduction';
            }

            // Generate short title from approach or generate generic one
            const shortTitle = generateShortTitle(details, experimentNumber);

            // Get experiment description (methods)
            const methods = getExperimentMethods(details);

            // Get previous experiment context for comparison
            const previousContext = previousPost ? getPreviousContext(previousPost) : null;

            // Get recommendations for next iteration
            const recommendations = getRecommendations(details);

            return `
                <div class="blog-post" id="${exp.id}">
                    <h2>Experiment #${experimentNumber}: ${shortTitle}</h2>
                    
                    <div class="blog-meta">
                        <span>üìÖ ${new Date(exp.created_at || exp.timestamp * 1000).toLocaleDateString()}</span>
                        <span>üî¨ ${exp.id}</span>
                        <span class="status-badge ${statusClass}">${exp.status}</span>
                        <span class="achievement-badge ${achievementClass}">${achievementIcon} ${achievementText}</span>
                    </div>

                    ${previousContext ? `
                        <div class="blog-section">
                            <h3>üîÑ Building on Previous Results</h3>
                            <p>${previousContext}</p>
                        </div>
                    ` : ''}

                    <div class="blog-section">
                        <h3>üî¨ Methods</h3>
                        ${methods}
                    </div>

                    <div class="blog-section">
                        <h3>üìä Results</h3>
                        <div class="metrics-grid">
                            <div class="metric-card">
                                <div class="metric-value">${exp.bitrate.toFixed(2)}</div>
                                <div class="metric-label">Bitrate (Mbps)</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-value">${reduction.toFixed(1)}%</div>
                                <div class="metric-label">Reduction vs HEVC</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-value">${achievementIcon}</div>
                                <div class="metric-label">${achievementText}</div>
                            </div>
                        </div>
                        ${exp.status === 'completed' ? `
                            <p>This experiment ${exp.bitrate < (previousPost?.experiment.bitrate || 10) ? '<strong style="color: #28a745;">improved</strong>' : '<strong style="color: #dc3545;">did not improve</strong>'} upon the previous iteration.</p>
                        ` : '<p>Experiment is still running...</p>'}
                    </div>

                    ${recommendations ? `
                        <div class="blog-section">
                            <h3>üí° Recommendations for Next Iteration</h3>
                            ${recommendations}
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function generateShortTitle(details, experimentNumber) {
            // Try to extract a meaningful short title from the details
            if (details && details.approach) {
                const approach = details.approach;
                if (approach.includes('JPEG')) return 'JPEG-based Compression';
                if (approach.includes('Downsample')) return 'Spatial Downsampling';
                if (approach.includes('Quantization')) return 'Advanced Quantization';
                if (approach.includes('DCT')) return 'DCT Transform';
                if (approach.includes('Neural') || approach.includes('PyTorch')) return 'Neural Codec';
                if (approach.includes('Wavelet')) return 'Wavelet Transform';
                if (approach.includes('Hybrid')) return 'Hybrid Approach';
            }
            return `Compression Approach ${experimentNumber}`;
        }

        function getExperimentMethods(details) {
            if (!details) {
                return '<p>Detailed methodology information not available for this experiment.</p>';
            }

            // Try to get description from generated_code
            let description = '';
            if (details.generated_code && details.generated_code.description) {
                description = details.generated_code.description;
            } else if (details.approach) {
                description = details.approach;
            }

            // Try to get expected improvement
            let expectedImprovement = '';
            if (details.generated_code && details.generated_code.expected_improvement) {
                expectedImprovement = `<p><strong>Expected Improvement:</strong> ${details.generated_code.expected_improvement}</p>`;
            }

            return `
                <p>${description || 'This experiment explores a new compression approach designed by the AI.'}</p>
                ${expectedImprovement}
                ${details.hypothesis ? `<p><strong>Hypothesis:</strong> ${details.hypothesis}</p>` : ''}
            `;
        }

        function getPreviousContext(previousPost) {
            if (!previousPost || !previousPost.experiment) return null;

            const prevExp = previousPost.experiment;
            const prevBitrate = prevExp.bitrate.toFixed(2);
            
            return `The previous experiment (Experiment #${previousPost.experimentNumber || 'N'}) achieved ${prevBitrate} Mbps. This iteration aims to improve upon that result by testing modifications based on analysis of what worked and what didn't.`;
        }

        function getRecommendations(details) {
            if (!details) return null;

            let recommendations = '';

            // Get next experiment suggestions
            if (details.next_experiment) {
                const next = details.next_experiment;
                recommendations += `<div class="recommendation-box">`;
                recommendations += `<h4>Suggested Next Approach</h4>`;
                if (next.approach) {
                    recommendations += `<p><strong>Approach:</strong> ${next.approach}</p>`;
                }
                if (next.changes && Array.isArray(next.changes)) {
                    recommendations += `<p><strong>Key Changes:</strong></p><ul>`;
                    next.changes.forEach(change => {
                        recommendations += `<li>${change}</li>`;
                    });
                    recommendations += `</ul>`;
                }
                recommendations += `</div>`;
            }

            // Get risks
            if (details.risks && Array.isArray(details.risks) && details.risks.length > 0) {
                recommendations += `<p><strong>Potential Risks:</strong></p><ul>`;
                details.risks.forEach(risk => {
                    recommendations += `<li>${risk}</li>`;
                });
                recommendations += `</ul>`;
            }

            // Get expected metrics
            if (details.expected_bitrate_mbps) {
                recommendations += `<p><strong>Expected Bitrate:</strong> ${details.expected_bitrate_mbps} Mbps</p>`;
            }
            if (details.confidence_score) {
                recommendations += `<div class="confidence-bar"><div class="confidence-fill" style="width: ${details.confidence_score * 100}%"></div></div>`;
                recommendations += `<p style="font-size: 0.9em; color: #666;">Confidence: ${(details.confidence_score * 100).toFixed(0)}%</p>`;
            }

            return recommendations || null;
        }

        // Load blog posts on page load
        loadBlogPosts();

        // Refresh every 5 minutes
        setInterval(loadBlogPosts, 5 * 60 * 1000);
    </script>
</body>
</html>
